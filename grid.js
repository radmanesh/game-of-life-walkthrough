// Generated by Copilot

import { GAME_CONFIG as CONFIG } from './config.js';

/**
 * @class Grid
 * @description Manages the game grid state and rules
 */
export class Grid {
    /** @type {number[][]} */
    #cells;
    /** @type {number} */
    #rows;
    /** @type {number} */
    #cols;

    /**
     * @param {number} rows - Number of rows
     * @param {number} cols - Number of columns
     */
    constructor(rows, cols) {
        this.#rows = rows;
        this.#cols = cols;
        this.#cells = Array(rows).fill().map(() => Array(cols).fill(0));
    }

    /**
     * @param {number} x - Row index
     * @param {number} y - Column index
     * @returns {number} Number of live neighbors
     */
    getNeighborCount(x, y) {
        let sum = 0;
        for(let i = -1; i < 2; i++) {
            for(let j = -1; j < 2; j++) {
                const row = (x + i + this.#rows) % this.#rows;
                const col = (y + j + this.#cols) % this.#cols;
                sum += this.#cells[row][col];
            }
        }
        return sum - this.#cells[x][y];
    }

    /**
     * @returns {Grid} New grid with next generation
     */
    getNextGeneration() {
        const nextGrid = new Grid(this.#rows, this.#cols);

        for(let i = 0; i < this.#rows; i++) {
            for(let j = 0; j < this.#cols; j++) {
                const neighbors = this.getNeighborCount(i, j);
                const isAlive = this.#cells[i][j] === 1;
                nextGrid.#cells[i][j] = this.#determineNextState(isAlive, neighbors);
            }
        }

        return nextGrid;
    }

    /**
     * @param {number} row
     * @param {number} col
     * @description Toggle cell state at given position
     */
    toggleCell(row, col) {
        if (this.#isValidPosition(row, col)) {
            this.#cells[row][col] = this.#cells[row][col] ? 0 : 1;
        }
    }

    /**
     * @private
     * @param {boolean} isAlive
     * @param {number} neighbors
     * @returns {number}
     */
    #determineNextState(isAlive, neighbors) {
        if (isAlive) {
            return (neighbors === 2 || neighbors === 3) ? 1 : 0;
        }
        return neighbors === 3 ? 1 : 0;
    }

    /**
     * @private
     * @param {number} row
     * @param {number} col
     * @returns {boolean}
     */
    #isValidPosition(row, col) {
        return row >= 0 && row < this.#rows && col >= 0 && col < this.#cols;
    }

    /**
     * @param {function(number, number, number, number): void} callback
     */
    forEachCell(callback) {
        for (let i = 0; i < this.#rows; i++) {
            for (let j = 0; j < this.#cols; j++) {
                callback(this.#cells[i][j], i, j, this.getNeighborCount(i, j));
            }
        }
    }
}
